# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T18:18:11+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import List, Optional

from pydantic import BaseModel, ConfigDict, Field, RootModel


class Account(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[int] = Field(None, description='The id of the account')
    identifier: Optional[str] = Field(None, description='Identifier for the account')
    servicepack_id: Optional[int] = Field(
        None, description='The servicepack id that defines the account.'
    )


class AddHostHeaderRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    domain_name: Optional[str] = Field(
        None, description='Host header domain name (e.g. alias.be or alias.site.be).'
    )


class AddSshKeyRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    public_key: Optional[str] = Field(None, description='Public key')


class AddSubsiteRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    domain_name: Optional[str] = Field(
        None, description='Subsite domain name (e.g. alias.be or subsite.site.be).'
    )
    path: Optional[str] = Field(
        None,
        description='Folder location for the subsite (when empty we use /subsites/site (e.g. /subsites/subsite.site.be)<br />\r\nThe path MUST pre-exist on the server. It WILL NOT be created automatically.',
    )


class AdditionalValidationAttribute(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Optional[str] = Field(
        None, description='Additional validation attribute field name.'
    )
    value: Optional[str] = Field(
        None, description='Additional validation attribute field value.'
    )


class Addon(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[int] = Field(None, description='The id of the addon')
    name: Optional[str] = Field(None, description='The name of the addon')


class Alias(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    destinations: Optional[List[str]] = Field(
        None, description='The alias destination e-mail addresses'
    )
    email_address: Optional[str] = Field(None, description='The alias e-mail address')


class AntiSpamTypes(Enum):
    none = 'none'
    advanced = 'advanced'
    basic = 'basic'


class ApplicationPool(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    installed_net_core_runtimes: Optional[List[str]] = Field(
        None, description='The installed .NET Core runtimes for the hosting account.'
    )
    pipeline_mode: Optional[str] = Field(
        None, description='The active pipeline mode for the hosting account.'
    )
    runtime: Optional[str] = Field(
        None, description='The active runtime for the hosting account.'
    )


class AssetType(Enum):
    domain = 'domain'
    linux_hosting = 'linux_hosting'
    mysql = 'mysql'
    dns = 'dns'
    mailbox = 'mailbox'
    windows_hosting = 'windows_hosting'


class AutoForward(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    copy_to_myself: Optional[bool] = Field(None, description='Copy to myself')
    email_addresses: Optional[List[str]] = Field(
        None, description='E-mail addresses to which e-mails are forwarded'
    )
    enabled: Optional[bool] = Field(None, description='Enabled')


class AutoRedirectConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: Optional[bool] = Field(None, description='Enabled')


class AutoReply(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: Optional[bool] = Field(None, description='Enabled')
    message: Optional[str] = Field(None, description='Message')
    subject: Optional[str] = Field(None, description='Subject')


class CatchAll(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    email_addresses: Optional[List[str]] = Field(
        None,
        description='E-mail addresses to which all e-mails are sent to inexistent mailboxes or aliases',
    )


class CompletionEstimation(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    estimate: Optional[datetime] = Field(
        None,
        description='The estimated time when the job should be finished.<br />\r\nUnexpected delays can always occur.<br />\r\nThe value is subject to change during the provisioning.',
    )


class CreateAccount(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    ftp_password: Optional[str] = Field(
        None,
        description='Ftp password for the account.<br />\r\nApplies only if the servicepack contains hosting.<br />\r\nPasswords have to adhere to following rules:<br /><ul><li>Between 8-20 characters.</li><li>Must be a mix of letters and digits.</li><li>Must contain at least one digit (0-9).</li><li>Must contain at least one letter (a-z).</li><li>Cannot contain spaces.</li><li>Cannot contain characters: * € $ & + } { \' " \\ </li></ul>',
    )
    identifier: Optional[str] = Field(
        None,
        description='An identifier for the account.<br />\r\nShould be a domain name for hosting accounts.',
    )
    servicepack_id: Optional[int] = Field(
        None, description='The servicepack id that defines the account.'
    )


class CreateAliasRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    destinations: Optional[List[str]] = Field(
        None, description='The alias destination e-mail addresses'
    )
    email_address: Optional[str] = Field(None, description='The alias e-mail')


class CreateCatchAllRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    email_address: Optional[str] = Field(
        None,
        description='E-mail address to which all e-mails are sent to inexistent mailboxes or aliases',
    )


class CreateMailboxRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    account_id: Optional[int] = Field(None, description='Mail zone account id')
    email_address: Optional[str] = Field(None, description='E-mail address')
    password: Optional[str] = Field(
        None,
        description='The password for the mailbox.<br />\r\nPasswords have to adhere to following rules:<br /><ul><li>Between 8-20 characters.</li><li>Must be a mix of letters and digits.</li><li>Must contain at least one digit (0-9).</li><li>Must contain at least one letter (a-z).</li><li>Cannot contain spaces.</li><li>Cannot contain characters: * € $ & + } { \' " \\ </li></ul>',
    )


class CreateMySqlDatabase(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    account_id: Optional[int] = Field(
        None, description='The id of the account on which to create the database.'
    )
    database_name: Optional[str] = Field(
        None,
        description='The name for the database. This will be prefixed during provisioning.\r\nThe provided name during creation will be different from the provisioned database name.',
    )
    password: Optional[str] = Field(
        None,
        description='The password for the database user.<br />\r\nPasswords have to adhere to following rules:<br /><ul><li>Between 8-20 characters.</li><li>Must be a mix of letters and digits.</li><li>Must contain at least one digit (0-9).</li><li>Must contain at least one letter (a-z).</li><li>Cannot contain spaces.</li><li>Cannot contain characters: * € $ & + } { \' " \\ </li></ul>',
    )


class CreateMySqlUser(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Optional[str] = Field(
        None,
        description='User name<br />\r\nUser names have to adhere to following rules:<br /><ul><li>Between 2-14 characters.</li><li>Must be a mix of letters and/or digits.</li><li>Must be lower cased.</li><li>Cannot contain spaces.</li></ul>',
    )
    password: Optional[str] = Field(
        None,
        description='The password for the database user.<br />\r\nPasswords have to adhere to following rules:<br /><ul><li>Between 8-20 characters.</li><li>Must be a mix of letters and digits.</li><li>Must contain at least one digit (0-9).</li><li>Must contain at least one letter (a-z).</li><li>Cannot contain spaces.</li><li>Cannot contain characters: * € $ & + } { \' " \\ </li></ul>',
    )


class CreateSmtpDomainRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    hostname: Optional[str] = Field(None, description='The smtp domain name')


class DnsRecord(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    content: Optional[str] = Field(
        None,
        description='Variable data depending on the record type.\r\n<ul><li>A: the IPv4 address.</li><li>CNAME: canonical name of an alias.</li><li>MX: fully qualified domain name of a mail host.</li><li>SRV: does not apply. Data for the SRV records can be found in specific properties.</li><li>TXT: free form text data.</li><li>CAA: format should match specific values for flag, tag and ca: "{flag} {tag} {ca}".\r\n        <ul><li>The flag. The values 128 (critical) or 0 (non-critical) are expected, with 0 as the default.</li><li>The tag. A tag specifies which actions an authorized CA can take in terms of issuing SSL/TLS certificates.<br /><ul><li>The value "issue": explicitly authorizes a single certificate authority to issue a certificate (any type) for the hostname.</li><li>The value "issuewild": explicitly authorizes a single certificate authority to issue a wildcard certificate (and only wildcard) for the hostname.</li><li>The value "iodef": specifies a URL to which a certificate authority may report policy violations.</li></ul></li><li>The ca. This is the domain of the CA (Certification Authority) that has the authority to issue certificates for the domain in question. If the value is a semicolon (;), it means that no CA has the authority to issue a certificate for that domain.</li></ul></li><li>ALIAS: canonical name of an alias.</li><li>TLSA: format should match specific values for usage, selector, matching type and data: "{usage} {selector} {matching_type} {data}"\r\n        <ul><li>The usage. The first field after the TLSA text in the DNS RR, specifies how to verify the certificate.<br /><ul><li>A value of 0 is for what is commonly called CA constraint (and PKIX-TA). The certificate provided when establishing TLS must be issued by the listed root-CA or one of its intermediate CAs, with a valid certification path to a root-CA already trusted by the application doing the verification.</li><li>A value of 1 is for what is commonly called Service certificate constraint (and PKIX-EE). The certificate used must match the TLSA record exactly, and it must also pass PKIX certification path validation to a trusted root-CA.</li><li>A value of 2 is for what is commonly called Trust Anchor Assertion (and DANE-TA). The certificate used has a valid certification path pointing back to the certificate mention in this record, but there is no need for it to pass the PKIX certification path validation to a trusted root-CA.</li><li>A value of 3 is for what is commonly called Domain issued certificate (and DANE-EE). The services uses a self-signed certificate. It is not signed by anyone else, and is exactly this record.</li></ul></li><li>The selector. When connecting to the service and a certificate is received, the selector field specifies which parts of it should be checked.<br /><ul><li>A value of 0 means to select the entire certificate for matching.</li><li>A value of 1 means to select just the public key for certificate matching. Matching the public key is often sufficient, as this is likely to be unique.</li></ul></li><li>The matching type.<br /><ul><li>A type of 0 means the entire information selected is present in the certificate association data.</li><li>A type of 1 means to do a SHA-256 hash of the selected data.</li><li>A type of 2 means to do a SHA-512 hash of the selected data.</li></ul></li><li>The actual data to be matched given the settings of the other fields. This is a long text string of hexadecimal data.</li></ul></li></ul>',
    )
    id: Optional[str] = Field(
        None,
        description='The id of the record\r\nThis value is ignored for creation of new records.',
    )
    port: Optional[int] = Field(
        None,
        description='The port for SRV records.<br />\r\nThe value MUST be a positive integer.<br />\r\nEditing the value is not possible. You should add a new SRV record and delete the existing record.',
    )
    priority: Optional[int] = Field(
        10,
        description='The priority for MX or SRV records.<br />\r\nA lower value means more preferred.<br />\r\nThe value MUST be a positive integer less or equal to 9999.',
    )
    protocol: Optional[str] = Field(
        'TCP',
        description='Used for the creation of SRV records. Possible options: TCP, UDP, ...<br />\r\nEditing the value is not possible. You should add a new SRV record and delete the existing record.',
    )
    record_name: Optional[str] = Field(
        None,
        description="The name of the record.<br />\r\nThis is the host name, alias defined by the record.<br />\r\nAn empty record or '@' is equal to the domain name.<br />\r\nApplies to A, MX, CNAME, TXT, CAA, ALIAS and TLSA records.<br />\r\nWhen type is TLSA the recommended value format is port number, protocol and host: _25._tcp.<br />\r\nDoes not apply for SRV records.",
    )
    service: Optional[str] = Field(
        None,
        description='The symbolic name of the desired service for SRV records.<br />\r\nEditing the value is not possible. You should add a new SRV record and can delete the existing record.',
    )
    target: Optional[str] = Field(
        None,
        description='The canonical hostname of the machine providing the service for SRV records.<br />\r\nEditing the value is not possible. You should add a new SRV record and delete the existing record.',
    )
    ttl: Optional[int] = Field(
        3600,
        description='Time to live of the record in seconds.<br />\r\nIt defines the time frame that clients can cache the information.<br />\r\nThe value MUST be between 60 and 86400. The default value is 3600 (= 1 hour).',
    )
    type: Optional[str] = Field(
        None,
        description='The type of the record (A, MX, CNAME, SRV, TXT, CAA, ALIAS and TLSA).',
    )
    weight: Optional[int] = Field(
        0,
        description='The weight for SRV records with the same priority.<br />\r\nA higher value means more preferred.',
    )


class Domain(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    domain_name: Optional[str] = Field(None, description='The domain name')
    expiration_date: Optional[datetime] = Field(
        None, description='Expiration date of the domain'
    )
    will_renew: Optional[bool] = Field(
        None,
        description='Indication of renewal.<br />\r\nNo value indicates that the renewal state could not be determined at the moment.',
    )


class EditDomainWillRenewRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    will_renew: Optional[bool] = Field(None, description='Indication of renewal.')


class EditNameServers(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    domain_name: Optional[str] = Field(None, description='The domain name to register.')
    name_servers: Optional[List[str]] = Field(None, description='List of name servers.')


class ExtraField(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Optional[str] = Field(None, description='Registrant extra field name.')
    value: Optional[str] = Field(None, description='Registrant extra field value.')


class FtpConfiguration(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: Optional[bool] = Field(None, description='Enable or disable FTP.')


class GzipConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: Optional[bool] = Field(None, description='Enabled')


class HostHeader(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: Optional[bool] = Field(
        None, description='Indicates if the host header is applied on the web server.'
    )
    name: Optional[str] = Field(None, description='The name of the host header.')


class Http2Configuration(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: Optional[bool] = Field(None, description='Enable or disable HTTP/2.')


class LetsEncryptConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: Optional[bool] = Field(None, description='Enabled')


class LinuxHosting(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    domain_name: Optional[str] = Field(
        None, description='Domain name for the Linux hosting account.'
    )
    servicepack_id: Optional[int] = Field(
        None, description='Id of Linux hosting service package.'
    )


class LinuxIpType(Enum):
    dedicated = 'dedicated'
    shared = 'shared'


class LinuxSite(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    host_headers: Optional[List[HostHeader]] = Field(
        None, description='Host headers for the website.'
    )
    http2_enabled: Optional[bool] = Field(
        None,
        description='Indicates whether http/2 protocol is enabled for the website.',
    )
    https_redirect_enabled: Optional[bool] = Field(
        None,
        description='Indicates whether automatic https redirection is enabled for the website.',
    )
    name: Optional[str] = Field(None, description='The name of the website.')
    path: Optional[str] = Field(None, description='The path of the website.')
    ssl_enabled: Optional[bool] = Field(
        None, description='Indicates whether ssl is enabled for the website.'
    )


class MailZoneAccount(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    account_id: Optional[int] = Field(
        None, description='Mail zone account id, use this value to create a mailbox'
    )
    size: Optional[int] = Field(None, description='Size of mailbox(es) in MB')


class Mailbox(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    actual_size: Optional[int] = Field(None, description='Used size in MB')
    max_size: Optional[int] = Field(None, description='Maximum size in MB')
    name: Optional[str] = None


class MailboxDetail(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    actual_size: Optional[int] = Field(None, description='Used size in MB')
    auto_forward: Optional[AutoForward] = None
    auto_reply: Optional[AutoReply] = None
    login: Optional[str] = Field(None, description='Login to connect with the mailbox')
    max_size: Optional[int] = Field(None, description='Maximum size in MB')
    name: Optional[str] = None


class MySqlDatabase(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    account_id: Optional[int] = Field(
        None, description='The account id for the database.'
    )
    actual_size: Optional[int] = Field(
        None, description='The actual size in MB for the database.'
    )
    hostname: Optional[str] = Field(None, description='Hostname')
    max_size: Optional[int] = Field(
        None, description='The maximim size in MB for the database.'
    )
    name: Optional[str] = Field(None, description='Database name')
    user_count: Optional[int] = Field(None, description='The number of users.')


class NameServer(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    ip: Optional[str] = Field(None, description='Nameserver ip')
    name: Optional[str] = Field(None, description='Nameserver name')


class PhpVersion(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    version: Optional[str] = Field(None, description='Php version')


class ProvisioningJobCompletion(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[str] = Field(None, description='The id of the job.')
    resource_links: Optional[List[str]] = Field(
        None, description='Links to the created resource(s).'
    )


class ProvisioningJobStatus(Enum):
    ongoing = 'ongoing'
    cancelled = 'cancelled'
    failed = 'failed'
    finished = 'finished'


class Registrant(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    address: Optional[str] = Field(None, description='Address of the registrant.')
    city: Optional[str] = Field(None, description='City of the registrant.')
    company_name: Optional[str] = Field(
        None,
        description='Company name of the registrant.<br />\r\nThe registrant is a company if not empty, otherwise the registrant is an individual when validating extra fields.',
    )
    country_code: Optional[str] = Field(
        None,
        description="Country code of the registrant.\r\nSyntax: 'BE', 'NL, 'FR', ...",
    )
    email: Optional[str] = Field(None, description='Email of the registrant.')
    enterprise_number: Optional[str] = Field(
        None,
        description="Enterprise number of the registrant.<br />\r\nSyntax: 'BE0123456789'",
    )
    fax: Optional[str] = Field(
        None, description="Fax of the registrant.\r\nSyntax: '+32.123456789'"
    )
    first_name: Optional[str] = Field(None, description='First name of the registrant.')
    language_code: Optional[str] = Field(
        None,
        description="Language code of the registrant.\r\nSyntax: 'nl', 'fr', 'en', 'de', ...",
    )
    last_name: Optional[str] = Field(None, description='Last name of the registrant.')
    phone: Optional[str] = Field(
        None, description="Phone of the registrant.<br />\r\nSyntax: '+32.123456789'"
    )
    postal_code: Optional[str] = Field(
        None, description='Postal code of the registrant.'
    )


class RegistrantInput(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    address: Optional[str] = Field(None, description='Address of the registrant.')
    city: Optional[str] = Field(None, description='City of the registrant.')
    company_name: Optional[str] = Field(
        None,
        description='Company name of the registrant.<br />\r\nThe registrant is a company if not empty, otherwise the registrant is an individual when validating extra fields.',
    )
    country_code: Optional[str] = Field(
        None,
        description="Country code of the registrant.\r\nSyntax: 'BE', 'NL, 'FR', ...",
    )
    email: Optional[str] = Field(None, description='Email of the registrant.')
    enterprise_number: Optional[str] = Field(
        None,
        description="Enterprise number of the registrant.<br />\r\nSyntax: 'BE0123456789'",
    )
    extra_fields: Optional[List[ExtraField]] = Field(
        None,
        description="List of registrant extra fields for the domain name.\r\n<table><tr><th>Extension</th><th>Registrant specifics</th><th>Required extra field(s)</th></tr><tr><td>.dk</td><td>is a company</td><td>CompanyNumber</td></tr><tr><td>.es</td><td>is a company</td><td>CompanyNumber</td></tr><tr><td>.es</td><td>is an individual</td><td>PassportNumber</td></tr><tr><td>.fr</td><td>is a company</td><td>CompanyNumber</td></tr><tr><td>.it</td><td>is an individual and has country code 'IT'</td><td>CodiceFiscal</td></tr><tr><td>.it</td><td>is an individual and has not country code 'IT'</td><td>PassportNumber</td></tr><tr><td>.nu</td><td>is a company</td><td>CompanyNumber</td></tr><tr><td>.nu</td><td>is an individual</td><td>PassportNumber</td></tr><tr><td>.se</td><td>is a company</td><td>CompanyNumber</td></tr><tr><td>.se</td><td>is an individual</td><td>PassportNumber</td></tr></table>",
    )
    fax: Optional[str] = Field(
        None, description="Fax of the registrant.\r\nSyntax: '+32.123456789'"
    )
    first_name: Optional[str] = Field(None, description='First name of the registrant.')
    language_code: Optional[str] = Field(
        None,
        description="Language code of the registrant.\r\nSyntax: 'nl', 'fr', 'en', 'de', ...",
    )
    last_name: Optional[str] = Field(None, description='Last name of the registrant.')
    phone: Optional[str] = Field(
        None, description="Phone of the registrant.<br />\r\nSyntax: '+32.123456789'"
    )
    postal_code: Optional[str] = Field(
        None, description='Postal code of the registrant.'
    )


class ScheduledTask(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cron_expression: Optional[str] = Field(
        None,
        description='Cron expression of scheduled task.<br />\r\n5-digit expressions (*/5 * * * *) are required in the following sequence:<br /><ul><li>Minute (0 - 59, also */5, */10, */15 and */30 as every 5 minutes, every 10 minutes, every quarter or every half-hour are allowed)</li><li>Hour (0 - 23, also * as every hour is allowed)</li><li>Day of the month (1 - 31, also * as every day is allowed)</li><li>Month (1 - 12 as January to December, also * as every month is allowed)</li><li>Day of the week (1 - 7 as Monday to Sunday, also * as every day is allowed)</li></ul>',
    )
    enabled: Optional[bool] = Field(None, description='Enabled.')
    id: Optional[str] = Field(
        None,
        description='The id of the scheduled task.<br />\r\nThis value is ignored for creation of new scheduled tasks.',
    )
    script_location: Optional[str] = Field(
        None, description='Absolute path from this linux hosting to execute.'
    )


class Servicepack(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[int] = Field(None, description='The id of the service pack')
    name: Optional[str] = Field(None, description='The name of the service pack')


class SiteBinding(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cert_thumbprint: Optional[str] = Field(
        None, description='The certificate thumbprint of the site binding.'
    )
    host_name: Optional[str] = Field(
        None, description='The host name of the site binding.'
    )
    ip_address: Optional[str] = Field(
        None, description='The IP address of the site binding.'
    )
    port: Optional[int] = Field(None, description='The port of the site binding.')
    protocol: Optional[str] = Field(
        None, description='The protocol of the site binding.'
    )
    ssl_enabled: Optional[bool] = Field(
        None, description='Indicates whether ssl is enabled for the binding.'
    )


class SmtpDomain(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: Optional[bool] = Field(None, description='Enabled')
    hostname: Optional[str] = Field(None, description='The smtp domain name')


class SshConfiguration(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: Optional[bool] = Field(None, description='Enable or disable SSH.')


class SshKey(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    fingerprint: Optional[str] = Field(
        None,
        description='The fingerprint of the public key.<br />\r\nThis value is ignored for creation of new SSH keys.',
    )
    public_key: Optional[str] = Field(None, description='Public key')


class SshKeyDetail(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    fingerprint: Optional[str] = Field(
        None,
        description='The fingerprint of the public key.<br />\r\nThis value is ignored for creation of new SSH keys.',
    )
    linux_hostings: Optional[List[str]] = Field(
        None, description='List of Linux hostings where SSH key is attached'
    )
    public_key: Optional[str] = Field(None, description='Public key')


class SslCertificateFileFormat(Enum):
    pfx = 'pfx'


class SslCertificateRequestValidationType(Enum):
    dns = 'dns'
    file = 'file'
    email = 'email'


class SslCertificateType(Enum):
    standard = 'standard'
    multi_domain = 'multi_domain'
    wildcard = 'wildcard'


class SslCertificateValidationLevel(Enum):
    domain_validated = 'domain_validated'
    organization_validated = 'organization_validated'
    extended_validated = 'extended_validated'


class SslCertificateVendor(Enum):
    sectigo = 'sectigo'


class SslSubjectAltNameType(Enum):
    dns = 'dns'
    ip = 'ip'


class TransferDomain(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    auth_code: Optional[str] = Field(
        None, description='Authorization code which allows the transfer to execute.'
    )
    domain_name: Optional[str] = Field(
        None,
        description='The domain name to transfer.<br />\r\nOnly pass the domain part and the tld.<br /><i>For abc.com, abc is the domain part, com is the tld.</i>',
    )
    name_servers: Optional[List[str]] = Field(
        None,
        description='List of name servers. When empty, the transfer will be done on default name servers.',
    )
    registrant: Optional[RegistrantInput] = None


class UpdateAliasRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    destinations: Optional[List[str]] = Field(
        None, description='The alias destination e-mail addresses'
    )


class UpdateAntiSpamRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    type: Optional[AntiSpamTypes] = None


class UpdateMailboxPasswordRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    password: Optional[str] = Field(
        None,
        description='The password for the database user.<br />\r\nPasswords have to adhere to following rules:<br /><ul><li>Between 8-20 characters.</li><li>Must be a mix of letters and digits.</li><li>Must contain at least one digit (0-9).</li><li>Must contain at least one letter (a-z).</li><li>Cannot contain spaces.</li><li>Cannot contain characters: * € $ & + } { \' " \\ </li></ul>',
    )


class UpdatePhpAPcuRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    apcu_size: Optional[int] = Field(None, description='The APcu size.')
    enabled: Optional[bool] = Field(None, description='Enables or disables APC.')


class UpdatePhpMemoryLimitRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    memory_limit: Optional[int] = Field(None, description='The php memory limit')


class UpdateSmtpDomainRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: Optional[bool] = Field(None, description='Enabled')


class UpdateUserPasswordRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    password: Optional[str] = Field(
        None,
        description='The password for the database user.<br />\r\nPasswords have to adhere to following rules:<br /><ul><li>Between 8-20 characters.</li><li>Must be a mix of letters and digits.</li><li>Must contain at least one digit (0-9).</li><li>Must contain at least one letter (a-z).</li><li>Cannot contain spaces.</li><li>Cannot contain characters: * € $ & + } { \' " \\ </li></ul>',
    )


class UpdateUserStatusRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: Optional[bool] = Field(None, description='Enabled')


class UserRights(Enum):
    read_and_write = 'read_and_write'
    read_only = 'read_only'


class ValidationErrorMessage(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    error_code: Optional[str] = None
    error_text: Optional[str] = None


class WindowsHosting(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    domain_name: Optional[str] = Field(
        None, description='Domain name for the Windows hosting account.'
    )
    servicepack_id: Optional[int] = Field(
        None, description='Id of Windows hosting service package.'
    )


class WindowsIpType(Enum):
    dedicated = 'dedicated'
    shared = 'shared'


class WindowsSite(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    bindings: Optional[List[SiteBinding]] = Field(
        None, description='The bindings for the website.'
    )
    name: Optional[str] = Field(None, description='The name of the website.')
    path: Optional[str] = Field(None, description='The path of the website.')


class AccountsGetResponse(RootModel[List[Account]]):
    root: List[Account]


class DnsDomainNameRecordsGetResponse(RootModel[List[DnsRecord]]):
    root: List[DnsRecord]


class DomainsGetResponse(RootModel[List[Domain]]):
    root: List[Domain]


class LinuxhostingsGetResponse(RootModel[List[LinuxHosting]]):
    root: List[LinuxHosting]


class LinuxhostingsDomainNamePhpsettingsAvailableversionsGetResponse(
    RootModel[List[PhpVersion]]
):
    root: List[PhpVersion]


class LinuxhostingsDomainNameScheduledtasksGetResponse(RootModel[List[ScheduledTask]]):
    root: List[ScheduledTask]


class LinuxhostingsDomainNameSshKeysGetResponse(RootModel[List[SshKey]]):
    root: List[SshKey]


class MailboxesGetResponse(RootModel[List[Mailbox]]):
    root: List[Mailbox]


class MysqldatabasesGetResponse(RootModel[List[MySqlDatabase]]):
    root: List[MySqlDatabase]


class ServicepacksGetResponse(RootModel[List[Servicepack]]):
    root: List[Servicepack]


class SshGetResponse(RootModel[List[SshKeyDetail]]):
    root: List[SshKeyDetail]


class WindowshostingsGetResponse(RootModel[List[WindowsHosting]]):
    root: List[WindowsHosting]


class AccountDetail(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    addons: Optional[List[Addon]] = Field(
        None, description='A list of addons applied to the account.'
    )
    id: Optional[int] = Field(None, description='The id of the account')
    identifier: Optional[str] = Field(None, description='Identifier for the account')
    servicepack: Optional[Servicepack] = None


class AntiSpam(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    allowed_types: Optional[List[AntiSpamTypes]] = Field(
        None, description='Allowed types of anti-spam scanning for this mail zone'
    )
    type: Optional[AntiSpamTypes] = None


class BadRequestResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    validation_errors: Optional[List[ValidationErrorMessage]] = Field(
        None,
        description='A list of validation errors that occurred when processing the request.',
    )


class CreateSslCertificateRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    additional_validation_attributes: Optional[List[AdditionalValidationAttribute]] = (
        Field(
            None,
            description='List of additional validation attributes for the certificate when choosing organization or extended validation.\r\n<table><tr><th>Name</th><th>Info</th><th>Required</th></tr><tr><td>Firstname</td><td>Firstname of the technical contact</td><td>Yes</td></tr><tr><td>Lastname</td><td>Lastname of the technical contact</td><td>Yes</td></tr><tr><td>Phone</td><td>Phone of the technical contact</td><td>Yes</td></tr><tr><td>EmailAddress</td><td>Email address of the technical contact</td><td>Yes</td></tr><tr><td>Street</td><td>Address street of the organization</td><td>Yes</td></tr><tr><td>Number</td><td>Address house number of the organization</td><td>Yes</td></tr><tr><td>PostalCode</td><td>Address postal code of the organization</td><td>Yes</td></tr><tr><td>VatCountryCode</td><td>VAT country code of the organization, ISO 3166-1 alpha-2 country code</td><td>Yes</td></tr><tr><td>OrganizationNumber</td><td>Business number of the organization</td><td>No</td></tr></table>',
        )
    )
    certificate_type: Optional[SslCertificateType] = None
    csr: Optional[str] = Field(
        None,
        description="The certificate signing request data.<br />\r\nThe certificate signing request subject should contain following attributes:<br /><table><tr><th>Name</th><th>Code</th><th>Format</th></tr><tr><td>CommonName</td><td>CN</td><td>Valid domain name, for example site.be, alias.site.be or *.site.be</td></tr><tr><td>Country</td><td>C</td><td>ISO 3166-1 alpha-2 country code</td></tr><tr><td>State</td><td>ST</td><td></td></tr><tr><td>Locality</td><td>L</td><td></td></tr><tr><td>Organization</td><td>O</td><td></td></tr><tr><td>EmailAddress</td><td>E</td><td>Valid email address</td></tr></table>\r\nThe certificate signing request should also contain all the additional aliases and domains (SAN's) for the certificate.",
    )
    validation_level: Optional[SslCertificateValidationLevel] = None


class DomainDetail(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    can_toggle_renew: Optional[bool] = Field(
        None, description='Indication if the domain renew state can be changed.'
    )
    domain_name: Optional[str] = Field(None, description='The domain name')
    expiration_date: Optional[datetime] = Field(
        None, description='Expiration date of the domain'
    )
    name_servers: Optional[List[NameServer]] = Field(
        None, description='Nameservers of the domain'
    )
    registrant: Optional[Registrant] = None
    will_renew: Optional[bool] = Field(
        None,
        description='Indication of renewal.<br />\r\nNo value indicates that the renewal state could not be determined at the moment.',
    )


class LinuxHostingDetail(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    actual_size: Optional[int] = Field(None, description='Used webspace size in MB')
    domain_name: Optional[str] = Field(
        None, description='Domain name for the Linux hosting account.'
    )
    ftp_enabled: Optional[bool] = Field(
        None, description='Indicates whether ftp is enabled for the hosting account.'
    )
    ftp_username: Optional[str] = Field(None, description='Ftp username')
    ip: Optional[str] = Field(None, description='Linux hosting IP address')
    ip_type: Optional[LinuxIpType] = None
    max_size: Optional[int] = Field(None, description='Maximum webspace size in MB')
    max_webspace_size: Optional[int] = Field(
        None, description='Maximum webspace size in MB<br />\r\nUse max_size instead.'
    )
    mysql_database_names: Optional[List[str]] = Field(
        None,
        description='A list of mysql databases linked to the hosting account.<br />\r\nDetails of the database can be read using the mysql database detail.',
    )
    php_version: Optional[str] = Field(
        None, description='The active php version for the hosting account.'
    )
    servicepack_id: Optional[int] = Field(
        None, description='Id of Linux hosting service package.'
    )
    sites: Optional[List[LinuxSite]] = Field(
        None, description='A list of websites on the hosting account.'
    )
    ssh_host: Optional[str] = Field(
        None, description='Ssh host of the linux hosting account'
    )
    ssh_username: Optional[str] = Field(None, description='Ssh username')
    webspace_usage: Optional[int] = Field(
        None, description='Used webspace size in MB<br />\r\nUse actual_size instead.'
    )


class MailZone(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aliases: Optional[List[Alias]] = Field(
        None,
        description='List of aliases on the mail zone<br />\r\nAn alias is an e-mail address (alias) that automatically forwards received e-mails to another e-mail address (destination).',
    )
    anti_spam: Optional[AntiSpam] = None
    available_accounts: Optional[List[MailZoneAccount]] = Field(
        None, description='List of mail zone accounts with their mailbox size.'
    )
    catch_all: Optional[CatchAll] = None
    enabled: Optional[bool] = Field(
        None, description='Indicates whether the mail zone is enabled.'
    )
    name: Optional[str] = None
    smtp_domains: Optional[List[SmtpDomain]] = Field(
        None,
        description='List of extra smtp domains on the mail zone<br />\r\nSMTP domain names allow you to link multiple domain names to a single e-mail address.<br />\r\nE-mails sent to an SMTP domain will be caught by the respective e-mail address on the main domain name.',
    )


class MySqlUser(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: Optional[bool] = Field(None, description='User status')
    name: Optional[str] = Field(None, description='User name')
    rights: Optional[UserRights] = None


class ProvisioningJobInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    completion: Optional[CompletionEstimation] = None
    id: Optional[str] = Field(None, description='The id of the job.')
    status: Optional[ProvisioningJobStatus] = None


class RegisterDomain(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    domain_name: Optional[str] = Field(
        None,
        description='The domain name to register.<br />\r\nOnly pass the domain part and the tld.<br /><i>For abc.com, abc is the domain part, com is the tld.</i>',
    )
    name_servers: Optional[List[str]] = Field(
        None,
        description='List of name servers. When empty, the registation will be done on default name servers.',
    )
    registrant: Optional[RegistrantInput] = None


class SslCertificate(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    common_name: Optional[str] = Field(
        None, description='The common name (e.g. domain.com) of the certificate.'
    )
    expires_after: Optional[datetime] = Field(
        None, description='The exact time the certificate will expire.'
    )
    sha1_fingerprint: Optional[str] = Field(
        None,
        description='The SHA-1 fingerprint of the certificate.<br />\r\nThe fingerprint is a cryptographic hash which is a short unique identification of the certificate.',
    )
    type: Optional[SslCertificateType] = None
    validation_level: Optional[SslCertificateValidationLevel] = None


class SslCertificateRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    certificate_type: Optional[SslCertificateType] = None
    common_name: Optional[str] = Field(
        None, description='The common name of the certificate request.'
    )
    id: Optional[int] = Field(None, description='The id of the certificate request.')
    order_code: Optional[str] = Field(
        None, description='The order code of the certificate request.'
    )
    validation_level: Optional[SslCertificateValidationLevel] = None
    vendor: Optional[SslCertificateVendor] = None


class SslCertificateRequestValidation(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    auto_validated: Optional[bool] = Field(
        None,
        description='Returns true if no user interaction is required and the domain validation will be verified automatic.',
    )
    cname_validation_content: Optional[str] = Field(
        None,
        description='The value-part (Point To) of the CNAME-record that must be created as part of domain verification.',
    )
    cname_validation_name: Optional[str] = Field(
        None,
        description='The host-part (Name) of the CNAME-record that must be created as part of domain verification.',
    )
    dns_name: Optional[str] = Field(
        None, description='A domain name of the certificate.'
    )
    email_addresses: Optional[List[str]] = Field(
        None, description='An array of eligible domain verification email addresses.'
    )
    file_validation_content: Optional[List[str]] = Field(
        None,
        description='The content your verification file must contain, consisting of three lines of plain-text.',
    )
    file_validation_url_http: Optional[str] = Field(
        None,
        description='The URL (http format) your verification file must be uploaded to as part of domain verification.',
    )
    file_validation_url_https: Optional[str] = Field(
        None,
        description='The URL (https format) your verification file must be uploaded to as part of domain verification.',
    )
    type: Optional[SslCertificateRequestValidationType] = None


class SslSubjectAltName(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    type: Optional[SslSubjectAltNameType] = None
    value: Optional[str] = Field(None, description='The value of the alt name.')


class WindowsHostingDetail(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    actual_size: Optional[int] = Field(None, description='Used webspace size in MB')
    application_pool: Optional[ApplicationPool] = None
    domain_name: Optional[str] = Field(
        None, description='Domain name for the Windows hosting account.'
    )
    ftp_username: Optional[str] = Field(None, description='Ftp username')
    ip: Optional[str] = Field(None, description='Windows hosting IP address')
    ip_type: Optional[WindowsIpType] = None
    max_size: Optional[int] = Field(None, description='Maximum webspace size in MB')
    mssql_database_names: Optional[List[str]] = Field(
        None,
        description='A list of mssql databases linked to the hosting account.<br />',
    )
    servicepack_id: Optional[int] = Field(
        None, description='Id of Windows hosting service package.'
    )
    sites: Optional[List[WindowsSite]] = Field(
        None, description='A list of websites on the hosting account.'
    )


class MysqldatabasesDatabaseNameUsersGetResponse(RootModel[List[MySqlUser]]):
    root: List[MySqlUser]


class SslcertificaterequestsGetResponse(RootModel[List[SslCertificateRequest]]):
    root: List[SslCertificateRequest]


class SslcertificatesGetResponse(RootModel[List[SslCertificate]]):
    root: List[SslCertificate]


class SslCertificateDetail(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    common_name: Optional[str] = Field(
        None, description='The common name (e.g. domain.com) of the certificate.'
    )
    expires_after: Optional[datetime] = Field(
        None, description='The exact time the certificate will expire.'
    )
    sha1_fingerprint: Optional[str] = Field(
        None,
        description='The SHA-1 fingerprint of the certificate.<br />\r\nThe fingerprint is a cryptographic hash which is a short unique identification of the certificate.',
    )
    subject_alt_names: Optional[List[SslSubjectAltName]] = Field(
        None, description='The list of all supported dns names in the certificate.'
    )
    type: Optional[SslCertificateType] = None
    validation_level: Optional[SslCertificateValidationLevel] = None


class SslCertificateRequestDetail(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    certificate_type: Optional[SslCertificateType] = None
    common_name: Optional[str] = Field(
        None, description='The common name of the certificate request.'
    )
    id: Optional[int] = Field(None, description='The id of the certificate request.')
    order_code: Optional[str] = Field(
        None, description='The order code of the certificate request.'
    )
    subject_alt_names: Optional[List[SslSubjectAltName]] = Field(
        None, description='The list of all supported domains in the certificate.'
    )
    validation_level: Optional[SslCertificateValidationLevel] = None
    validations: Optional[List[SslCertificateRequestValidation]] = Field(
        None,
        description='The list of dns names to be validated with the information related to domain verification.',
    )
    vendor: Optional[SslCertificateVendor] = None
